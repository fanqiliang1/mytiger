package parser;

<<<<<<< HEAD
=======
import java.util.LinkedList;
import java.util.NoSuchElementException;

>>>>>>> Lab2Solution
import lexer.Lexer;
import lexer.Token;
import lexer.Token.Kind;

public class Parser {
	Lexer lexer;
	Token current;
<<<<<<< HEAD
=======
	LinkedList<Token> savedToken;
>>>>>>> Lab2Solution

	public Parser(String fname, java.io.InputStream fstream) {
		lexer = new Lexer(fname, fstream);
		current = lexer.nextToken();
<<<<<<< HEAD
=======
		savedToken = new LinkedList<Token>();
>>>>>>> Lab2Solution
	}

	// /////////////////////////////////////////////
	// utility methods to connect the lexer
	// and the parser.

	private void advance() {
<<<<<<< HEAD
		current = lexer.nextToken();
=======
		// changed a little bit, we can save token now, use this tech to do look ahead
		Token token;
		try {
			token = savedToken.removeFirst();
			current = token;
		} catch (NoSuchElementException e) {
			current = lexer.nextToken();
		}
	}

	private void saveToken(Token token) {
		savedToken.addFirst(token);
>>>>>>> Lab2Solution
	}

	private void eatToken(Kind kind) {
		if (kind == current.kind)
			advance();
		else {
<<<<<<< HEAD
=======
			System.out.format("in line %d: ", lexer.lineno);
			//because we can save token, lineno maybe not accurate
>>>>>>> Lab2Solution
			System.out.println("Expects: " + kind.toString());
			System.out.println("But got: " + current.kind.toString());
			System.exit(1);
		}
	}

<<<<<<< HEAD
	private void error() {
		System.out.println("Syntax error: compilation aborting...\n");
=======
	private void error(String hint) {
		System.out.format("Syntax error: hint: %s, line %d, current kind %s\n",
				hint, lexer.lineno, current.kind.toString());
		//because we can save token, lineno maybe not accurate
>>>>>>> Lab2Solution
		System.exit(1);
		return;
	}

	// ////////////////////////////////////////////////////////////
	// below are method for parsing.

	// A bunch of parsing methods to parse expressions. The messy
	// parts are to deal with precedence and associativity.

	// ExpList -> Exp ExpRest*
	// ->
	// ExpRest -> , Exp
<<<<<<< HEAD
	private void parseExpList() {
		if (current.kind == Kind.TOKEN_RPAREN)
			return;
		parseExp();
		while (current.kind == Kind.TOKEN_COMMER) {
			advance();
			parseExp();
		}
		return;
=======
	private LinkedList<ast.exp.T> parseExpList() {
		LinkedList<ast.exp.T> result = new LinkedList<ast.exp.T>();
		if (current.kind == Kind.TOKEN_RPAREN)
			return result;
		result.add(parseExp());
		while (current.kind == Kind.TOKEN_COMMER) {
			advance();
			result.add(parseExp());
		}
		return result;
>>>>>>> Lab2Solution
	}

	// AtomExp -> (exp)
	// -> INTEGER_LITERAL
	// -> true
	// -> false
	// -> this
	// -> id
	// -> new int [exp]
	// -> new id ()
<<<<<<< HEAD
	private void parseAtomExp() {
		switch (current.kind) {
		case TOKEN_LPAREN:
			advance();
			parseExp();
			eatToken(Kind.TOKEN_RPAREN);
			return;
		case TOKEN_NUM:
			advance();
			return;
		case TOKEN_TRUE:
			advance();
			return;
		case TOKEN_THIS:
			advance();
			return;
		case TOKEN_ID:
			advance();
			return;
=======
	private ast.exp.T parseAtomExp() {
		ast.exp.T result = null;
		switch (current.kind) {
		case TOKEN_LPAREN:
			advance();
			result = parseExp();
			eatToken(Kind.TOKEN_RPAREN);
			return result;
		case TOKEN_NUM:
			result = new ast.exp.Num(Integer.valueOf(current.lexeme));
			advance();
			return result;
		case TOKEN_TRUE:
			advance();
			return new ast.exp.True();
		case TOKEN_FALSE:
			advance();
			return new ast.exp.False();
		case TOKEN_THIS:
			advance();
			return new ast.exp.This();
		case TOKEN_ID:
			result = new ast.exp.Id(current.lexeme);
			advance();
			return result;
>>>>>>> Lab2Solution
		case TOKEN_NEW: {
			advance();
			switch (current.kind) {
			case TOKEN_INT:
				advance();
				eatToken(Kind.TOKEN_LBRACK);
<<<<<<< HEAD
				parseExp();
				eatToken(Kind.TOKEN_RBRACK);
				return;
			case TOKEN_ID:
				advance();
				eatToken(Kind.TOKEN_LPAREN);
				eatToken(Kind.TOKEN_RPAREN);
				return;
			default:
				error();
				return;
			}
		}
		default:
			error();
			return;
=======
				result = parseExp();
				eatToken(Kind.TOKEN_RBRACK);
				return new ast.exp.NewIntArray(result);
			case TOKEN_ID:
				result = new ast.exp.NewObject(current.lexeme);
				advance();
				eatToken(Kind.TOKEN_LPAREN);
				eatToken(Kind.TOKEN_RPAREN);
				return result;
			default:
				error("in parseAtomExp, TOKEN_NEW case");
				return null;
			}
		}
		default:
			error("in parseAtomExp, default case");
			return null;
>>>>>>> Lab2Solution
		}
	}

	// NotExp -> AtomExp
	// -> AtomExp .id (expList)
	// -> AtomExp [exp]
	// -> AtomExp .length
<<<<<<< HEAD
	private void parseNotExp() {
		parseAtomExp();
=======
	private ast.exp.T parseNotExp() {
		ast.exp.T atomExp = parseAtomExp();
>>>>>>> Lab2Solution
		while (current.kind == Kind.TOKEN_DOT
				|| current.kind == Kind.TOKEN_LBRACK) {
			if (current.kind == Kind.TOKEN_DOT) {
				advance();
				if (current.kind == Kind.TOKEN_LENGTH) {
					advance();
<<<<<<< HEAD
					return;
				}
				eatToken(Kind.TOKEN_ID);
				eatToken(Kind.TOKEN_LPAREN);
				parseExpList();
				eatToken(Kind.TOKEN_RPAREN);
			} else {
				advance();
				parseExp();
				eatToken(Kind.TOKEN_RBRACK);
			}
		}
		return;
=======
					atomExp = new ast.exp.Length(atomExp);
				} else {
					String id = current.lexeme;
					eatToken(Kind.TOKEN_ID);
					eatToken(Kind.TOKEN_LPAREN);
					LinkedList<ast.exp.T> expList = parseExpList();
					eatToken(Kind.TOKEN_RPAREN);
					atomExp = new ast.exp.Call(atomExp, id, expList);
				}
			} else {
				// must be TOKEN_LBRACK
				advance();
				ast.exp.T exp = parseExp();
				eatToken(Kind.TOKEN_RBRACK);
				atomExp =  new ast.exp.ArraySelect(atomExp, exp);
			}
		}
		return atomExp;
>>>>>>> Lab2Solution
	}

	// TimesExp -> ! TimesExp
	// -> NotExp
<<<<<<< HEAD
	private void parseTimesExp() {
		while (current.kind == Kind.TOKEN_NOT) {
			advance();
		}
		parseNotExp();
		return;
=======
	private ast.exp.T parseTimesExp() {
		int nest = 0;
		while (current.kind == Kind.TOKEN_NOT) {
			// handle nested not exp like !!!exp
			nest += 1;
			advance();
		}
		ast.exp.T notExp = parseNotExp();
		for (int i = 0; i < nest; i++)
			notExp = new ast.exp.Not(notExp);
		return notExp;
>>>>>>> Lab2Solution
	}

	// AddSubExp -> TimesExp * TimesExp
	// -> TimesExp
<<<<<<< HEAD
	private void parseAddSubExp() {
		parseTimesExp();
		while (current.kind == Kind.TOKEN_TIMES) {
			advance();
			parseTimesExp();
		}
		return;
=======
	private ast.exp.T parseAddSubExp() {
		ast.exp.T timesExp = parseTimesExp();
		while (current.kind == Kind.TOKEN_TIMES) {
			advance();
			timesExp = new ast.exp.Times(timesExp, parseTimesExp());
		}
		return timesExp;
>>>>>>> Lab2Solution
	}

	// LtExp -> AddSubExp + AddSubExp
	// -> AddSubExp - AddSubExp
	// -> AddSubExp
<<<<<<< HEAD
	private void parseLtExp() {
		parseAddSubExp();
		while (current.kind == Kind.TOKEN_ADD || current.kind == Kind.TOKEN_SUB) {
			advance();
			parseAddSubExp();
		}
		return;
=======
	private ast.exp.T parseLtExp() {
		ast.exp.T addSubExp = parseAddSubExp();
		while (current.kind == Kind.TOKEN_ADD || current.kind == Kind.TOKEN_SUB) {
			if (current.kind == Kind.TOKEN_ADD) {
				advance();
				addSubExp = new ast.exp.Add(addSubExp, parseAddSubExp());
			} else {
				//must Kind.TOKEN_SUB
				advance();
				addSubExp = new ast.exp.Sub(addSubExp, parseAddSubExp());
			}
		}
		return addSubExp;
>>>>>>> Lab2Solution
	}

	// AndExp -> LtExp < LtExp
	// -> LtExp
<<<<<<< HEAD
	private void parseAndExp() {
		parseLtExp();
		while (current.kind == Kind.TOKEN_LT) {
			advance();
			parseLtExp();
		}
		return;
=======
	private ast.exp.T parseAndExp() {
		ast.exp.T ltExp = parseLtExp();;
		while (current.kind == Kind.TOKEN_LT) {
			advance();
			ltExp = new ast.exp.Lt(ltExp, parseLtExp());
		}
		return ltExp;
>>>>>>> Lab2Solution
	}

	// Exp -> AndExp && AndExp
	// -> AndExp
<<<<<<< HEAD
	private void parseExp() {
		parseAndExp();
		while (current.kind == Kind.TOKEN_AND) {
			advance();
			parseAndExp();
		}
		return;
=======
	private ast.exp.T parseExp() {
		ast.exp.T andExp = parseAndExp();
		while (current.kind == Kind.TOKEN_AND) {
			advance();
			andExp = new ast.exp.And(andExp, parseAndExp());
		}
		return andExp;
>>>>>>> Lab2Solution
	}

	// Statement -> { Statement* }
	// -> if ( Exp ) Statement else Statement
	// -> while ( Exp ) Statement
	// -> System.out.println ( Exp ) ;
	// -> id = Exp ;
	// -> id [ Exp ]= Exp ;
<<<<<<< HEAD
	private void parseStatement() {
		// Lab1. Exercise 4: Fill in the missing code
		// to parse a statement.
		new util.Todo();
=======
	private ast.stm.T parseStatement() {
		switch (current.kind) {
		case TOKEN_LBRACE:
			advance();
			LinkedList<ast.stm.T> statements = parseStatements();
			eatToken(Kind.TOKEN_RBRACE);
			return new ast.stm.Block(statements);
		case TOKEN_IF:
			advance();
			eatToken(Kind.TOKEN_LPAREN);
			ast.exp.T condition = parseExp();
			eatToken(Kind.TOKEN_RPAREN);
			ast.stm.T if_body = parseStatement();
			eatToken(Kind.TOKEN_ELSE);
			ast.stm.T else_body = parseStatement();
			return new ast.stm.If(condition, if_body, else_body);
		case TOKEN_WHILE:
			advance();
			eatToken(Kind.TOKEN_LPAREN);
			ast.exp.T cond = parseExp();
			eatToken(Kind.TOKEN_RPAREN);
			ast.stm.T body = parseStatement();
			return new ast.stm.While(cond, body);
		case TOKEN_SYSTEM:
			advance();
			eatToken(Kind.TOKEN_DOT);
			eatToken(Kind.TOKEN_OUT);
			eatToken(Kind.TOKEN_DOT);
			eatToken(Kind.TOKEN_PRINTLN);
			eatToken(Kind.TOKEN_LPAREN);
			ast.exp.T exp = parseExp();
			eatToken(Kind.TOKEN_RPAREN);
			eatToken(Kind.TOKEN_SEMI);
			return new ast.stm.Print(exp);
		case TOKEN_ID:
			String id = current.lexeme;
			advance();
			if (current.kind == Kind.TOKEN_ASSIGN) {
				advance();
				ast.exp.T exp1 = parseExp();
				eatToken(Kind.TOKEN_SEMI);
				return new ast.stm.Assign(id, exp1);
			} else if (current.kind == Kind.TOKEN_LBRACK) {
				advance();
				ast.exp.T index = parseExp();
				eatToken(Kind.TOKEN_RBRACK);
				eatToken(Kind.TOKEN_ASSIGN);
				ast.exp.T exp2 = parseExp();
				eatToken(Kind.TOKEN_SEMI);
				return new ast.stm.AssignArray(id, index, exp2);
			} else {
				error("in parseStatement, TOKEN_ID case");
				return null;
			}
		default:
			error("in parseStatement, default case");
			return null;
		}
>>>>>>> Lab2Solution
	}

	// Statements -> Statement Statements
	// ->
<<<<<<< HEAD
	private void parseStatements() {
=======
	private LinkedList<ast.stm.T> parseStatements() {
		LinkedList<ast.stm.T> result = new LinkedList<ast.stm.T>();
>>>>>>> Lab2Solution
		while (current.kind == Kind.TOKEN_LBRACE
				|| current.kind == Kind.TOKEN_IF
				|| current.kind == Kind.TOKEN_WHILE
				|| current.kind == Kind.TOKEN_SYSTEM
				|| current.kind == Kind.TOKEN_ID) {
<<<<<<< HEAD
			parseStatement();
		}
		return;
=======
			result.add(parseStatement());
		}
		return result;
>>>>>>> Lab2Solution
	}

	// Type -> int []
	// -> boolean
	// -> int
	// -> id
<<<<<<< HEAD
	private void parseType() {
		// Lab1. Exercise 4: Fill in the missing code
		// to parse a type.
		new util.Todo();
	}

	// VarDecl -> Type id ;
	private void parseVarDecl() {
		// to parse the "Type" nonterminal in this method, instead of writing
		// a fresh one.
		parseType();
		eatToken(Kind.TOKEN_ID);
		eatToken(Kind.TOKEN_SEMI);
		return;
=======
	private ast.type.T parseType() {
		switch (current.kind) {
		case TOKEN_INT:
			advance();
			if (current.kind == Kind.TOKEN_LBRACK) {
				advance();
				eatToken(Kind.TOKEN_RBRACK);
				return new ast.type.IntArray();
			} else
				return new ast.type.Int();
		case TOKEN_BOOLEAN:
			advance();
			return new ast.type.Boolean();
		case TOKEN_ID:// class type
			String id = current.lexeme;
			advance();
			return new ast.type.Class(id);
		default:
			error("in parseType, default case");
			return null;
		}
	}

	// VarDecl -> Type id ;
	private ast.dec.T parseVarDecl() {
		// to parse the "Type" nonterminal in this method, instead of writing
		// a fresh one.

		ast.type.T type = parseType();
		String id = current.lexeme;
		eatToken(Kind.TOKEN_ID);
		eatToken(Kind.TOKEN_SEMI);
		return new ast.dec.Dec(type, id);
>>>>>>> Lab2Solution
	}

	// VarDecls -> VarDecl VarDecls
	// ->
<<<<<<< HEAD
	private void parseVarDecls() {
		while (current.kind == Kind.TOKEN_INT
				|| current.kind == Kind.TOKEN_BOOLEAN
				|| current.kind == Kind.TOKEN_ID) {
			parseVarDecl();
		}
		return;
=======
	private LinkedList<ast.dec.T> parseVarDecls() {
		LinkedList<ast.dec.T> result = new LinkedList<ast.dec.T>();
		for (;;) {
			if (current.kind == Kind.TOKEN_INT
					|| current.kind == Kind.TOKEN_BOOLEAN)
				result.add(parseVarDecl());
			else if (current.kind == Kind.TOKEN_ID) {
				/* *
				 * Here's a trick: because Type could be TOKEN_ID, and statement
				 * could also started with TOKEN_ID, so we have to look ahead
				 * for couple of tokens to see how to do it
				 */
				Token saved = current;
				advance();
				if (current.kind == Kind.TOKEN_ID) {
					saveToken(current);
					current = saved;
					result.add(parseVarDecl());
				} else {
					saveToken(current);
					current = saved;
					return result;
				}
			} else
				return result;
		}
>>>>>>> Lab2Solution
	}

	// FormalList -> Type id FormalRest*
	// ->
	// FormalRest -> , Type id
<<<<<<< HEAD
	private void parseFormalList() {
		if (current.kind == Kind.TOKEN_INT
				|| current.kind == Kind.TOKEN_BOOLEAN
				|| current.kind == Kind.TOKEN_ID) {
			parseType();
			eatToken(Kind.TOKEN_ID);
			while (current.kind == Kind.TOKEN_COMMER) {
				advance();
				parseType();
				eatToken(Kind.TOKEN_ID);
			}
		}
		return;
=======
	private LinkedList<ast.dec.T> parseFormalList() {
		LinkedList<ast.dec.T> result = new LinkedList<ast.dec.T>();
		if (current.kind == Kind.TOKEN_INT
				|| current.kind == Kind.TOKEN_BOOLEAN
				|| current.kind == Kind.TOKEN_ID) {
			ast.type.T type = parseType();
			String id = current.lexeme;
			eatToken(Kind.TOKEN_ID);
			result.add(new ast.dec.Dec(type, id));
			while (current.kind == Kind.TOKEN_COMMER) {
				advance();
				ast.type.T type1 = parseType();
				String id1 = current.lexeme;
				eatToken(Kind.TOKEN_ID);
				result.add(new ast.dec.Dec(type1, id1));
			}
		}
		return result;
>>>>>>> Lab2Solution
	}

	// Method -> public Type id ( FormalList )
	// { VarDecl* Statement* return Exp ;}
<<<<<<< HEAD
	private void parseMethod() {
		// Lab1. Exercise 4: Fill in the missing code
		// to parse a method.
		new util.Todo();
		return;
=======
	private ast.method.Method parseMethod() {
		switch (current.kind) {
		case TOKEN_PUBLIC:
			advance();
			ast.type.T type = parseType();
			String id = current.lexeme;
			eatToken(Kind.TOKEN_ID);
			eatToken(Kind.TOKEN_LPAREN);
			LinkedList<ast.dec.T> formalList = parseFormalList();
			eatToken(Kind.TOKEN_RPAREN);
			eatToken(Kind.TOKEN_LBRACE);
			LinkedList<ast.dec.T> varDecl = parseVarDecls();
			LinkedList<ast.stm.T> statements = parseStatements();
			eatToken(Kind.TOKEN_RETURN);
			ast.exp.T exp = parseExp();
			eatToken(Kind.TOKEN_SEMI);
			eatToken(Kind.TOKEN_RBRACE);
			return new ast.method.Method(type, id, formalList, varDecl, statements, exp);
		default:
			error("in parseMethod, default case");
			return null;
		}
>>>>>>> Lab2Solution
	}

	// MethodDecls -> MethodDecl MethodDecls
	// ->
<<<<<<< HEAD
	private void parseMethodDecls() {
		while (current.kind == Kind.TOKEN_PUBLIC) {
			parseMethod();
		}
		return;
=======
	private LinkedList<ast.method.T> parseMethodDecls() {
		LinkedList<ast.method.T> methodDecls = new LinkedList<ast.method.T>();
		while (current.kind == Kind.TOKEN_PUBLIC)
			methodDecls.add(parseMethod());
		return methodDecls;
>>>>>>> Lab2Solution
	}

	// ClassDecl -> class id { VarDecl* MethodDecl* }
	// -> class id extends id { VarDecl* MethodDecl* }
<<<<<<< HEAD
	private void parseClassDecl() {
		eatToken(Kind.TOKEN_CLASS);
		eatToken(Kind.TOKEN_ID);
		if (current.kind == Kind.TOKEN_EXTENDS) {
			eatToken(Kind.TOKEN_EXTENDS);
			eatToken(Kind.TOKEN_ID);
		}
		eatToken(Kind.TOKEN_LBRACE);
		parseVarDecls();
		parseMethodDecls();
		eatToken(Kind.TOKEN_RBRACE);
		return;
=======
	private ast.classs.T parseClassDecl() {
		eatToken(Kind.TOKEN_CLASS);
		String id = current.lexeme;
		eatToken(Kind.TOKEN_ID);
		String extendss = null;
		if (current.kind == Kind.TOKEN_EXTENDS) {
			eatToken(Kind.TOKEN_EXTENDS);
			extendss = current.lexeme;
			eatToken(Kind.TOKEN_ID);
		}
		eatToken(Kind.TOKEN_LBRACE);
		LinkedList<ast.dec.T> varDecls = parseVarDecls();
		LinkedList<ast.method.T> methodDecl = parseMethodDecls();
		eatToken(Kind.TOKEN_RBRACE);
		return new ast.classs.Class(id, extendss, varDecls, methodDecl);
>>>>>>> Lab2Solution
	}

	// ClassDecls -> ClassDecl ClassDecls
	// ->
<<<<<<< HEAD
	private void parseClassDecls() {
		while (current.kind == Kind.TOKEN_CLASS) {
			parseClassDecl();
		}
		return;
=======
	private LinkedList<ast.classs.T> parseClassDecls() {
		LinkedList<ast.classs.T> classDecl = new LinkedList<ast.classs.T>();
		while (current.kind == Kind.TOKEN_CLASS)
			classDecl.add(parseClassDecl());
		return classDecl;
>>>>>>> Lab2Solution
	}

	// MainClass -> class id
	// {
	// public static void main ( String [] id )
	// {
	// Statement
	// }
	// }
<<<<<<< HEAD
	private void parseMainClass() {
		// Lab1. Exercise 4: Fill in the missing code
		// to parse a main class as described by the
		// grammar above.
		new util.Todo();
	}

	// Program -> MainClass ClassDecl*
	private void parseProgram() {
		parseMainClass();
		parseClassDecls();
		eatToken(Kind.TOKEN_EOF);
		return;
	}

	public ast.program.T parse() {
		parseProgram();
		return null;
=======
	private ast.mainClass.T parseMainClass() {
		switch (current.kind) {
		case TOKEN_CLASS:
			advance();
			String id = current.lexeme;
			eatToken(Kind.TOKEN_ID);
			eatToken(Kind.TOKEN_LBRACE);
			eatToken(Kind.TOKEN_PUBLIC);
			eatToken(Kind.TOKEN_STATIC);
			eatToken(Kind.TOKEN_VOID);
			eatToken(Kind.TOKEN_MAIN);
			eatToken(Kind.TOKEN_LPAREN);
			eatToken(Kind.TOKEN_STRING);
			eatToken(Kind.TOKEN_LBRACK);
			eatToken(Kind.TOKEN_RBRACK);
			String argsId = current.lexeme;
			eatToken(Kind.TOKEN_ID);
			eatToken(Kind.TOKEN_RPAREN);
			eatToken(Kind.TOKEN_LBRACE);
			ast.stm.T statement = parseStatement();
			eatToken(Kind.TOKEN_RBRACE);
			eatToken(Kind.TOKEN_RBRACE);
			return new ast.mainClass.MainClass(id, argsId, statement);
		default:
			error("in parseMainClass, default case");
			return null;
		}
	}

	// Program -> MainClass ClassDecl*
	private ast.program.T parseProgram() {
		ast.mainClass.T mainClass = parseMainClass();
		LinkedList<ast.classs.T> classs = parseClassDecls();
		eatToken(Kind.TOKEN_EOF);
		return new ast.program.Program(mainClass, classs);
	}

	public ast.program.T parse() {
		return parseProgram();
>>>>>>> Lab2Solution
	}
}
